/**
 * Action Executor for AI Terminal Actions
 *
 * Executes the actions generated by Claude on the terminal PTY.
 */

import * as pty from "node-pty";
import chalk from "chalk";
import type { AIAction, AIServiceCallbacks } from "./types.js";

/** Map of special key names to their terminal escape sequences */
const SPECIAL_KEYS: Record<string, string> = {
  // Basic keys
  Enter: "\r",
  Tab: "\t",
  Escape: "\x1b",
  Backspace: "\x7f",
  Delete: "\x1b[3~",

  // Arrow keys
  Up: "\x1b[A",
  Down: "\x1b[B",
  Right: "\x1b[C",
  Left: "\x1b[D",

  // Navigation keys
  Home: "\x1b[H",
  End: "\x1b[F",
  PageUp: "\x1b[5~",
  PageDown: "\x1b[6~",

  // Control sequences
  "Ctrl+C": "\x03",
  "Ctrl+D": "\x04",
  "Ctrl+Z": "\x1a",
  "Ctrl+L": "\x0c",
  "Ctrl+A": "\x01",
  "Ctrl+E": "\x05",
  "Ctrl+K": "\x0b",
  "Ctrl+U": "\x15",
  "Ctrl+W": "\x17",
  "Ctrl+R": "\x12",
  "Ctrl+[": "\x1b",
};

/**
 * Sleep utility function
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Convert a keystroke value to the actual characters to send to the terminal
 */
function resolveKeystroke(value: string): string {
  // Check if it's a special key
  if (SPECIAL_KEYS[value]) {
    return SPECIAL_KEYS[value];
  }

  // Regular text - send as-is
  return value;
}

/**
 * Execute a single action on the terminal
 *
 * @param action - The action to execute
 * @param terminal - The PTY terminal instance
 * @param callbacks - Optional callbacks for action events
 * @returns true if the action requests a screen snapshot
 */
export async function executeAction(
  action: AIAction,
  terminal: pty.IPty,
  callbacks?: AIServiceCallbacks
): Promise<boolean> {
  callbacks?.onActionStart?.(action);

  switch (action.type) {
    case "keystroke": {
      const keys = resolveKeystroke(action.value);
      console.log(
        chalk.cyan(`  ‚å®Ô∏è  Keystroke: ${JSON.stringify(action.value)}`)
      );
      terminal.write(keys);
      break;
    }

    case "delay": {
      const ms = action.value;
      console.log(chalk.gray(`  ‚è±Ô∏è  Delay: ${ms}ms`));
      await sleep(ms);
      break;
    }

    case "message": {
      // Log the AI's message/explanation
      console.log(chalk.blue(`  üí¨ AI: ${action.value}`));
      break;
    }

    case "request_screen": {
      let sliceInfo = " (default: last ~15k chars)";
      if (action.value?.sliceStart !== undefined || action.value?.sliceEnd !== undefined) {
        const start = action.value.sliceStart ?? 0;
        const end = action.value.sliceEnd ?? "end";
        sliceInfo = ` [${start}:${end}]`;
      }
      console.log(chalk.magenta(`  üì∏ Screen snapshot requested${sliceInfo}`));
      callbacks?.onActionComplete?.(action);
      return true;
    }
  }

  callbacks?.onActionComplete?.(action);
  return false;
}

/**
 * Execute a list of actions in sequence
 *
 * @param actions - Array of actions to execute
 * @param terminal - The PTY terminal instance
 * @param callbacks - Optional callbacks for action events
 * @returns true if any action requested a screen snapshot
 */
export async function executeActions(
  actions: AIAction[],
  terminal: pty.IPty,
  callbacks?: AIServiceCallbacks
): Promise<boolean> {
  let screenRequested = false;

  for (const action of actions) {
    const requested = await executeAction(action, terminal, callbacks);
    if (requested) {
      screenRequested = true;
      // Don't break - execute all actions up to and including the screen request
    }
  }

  return screenRequested;
}

/**
 * Check if the last action in the array is a screen request
 * This determines whether the AI loop should continue
 */
export function hasScreenRequest(actions: AIAction[]): boolean {
  if (actions.length === 0) return false;
  const lastAction = actions[actions.length - 1];
  return lastAction.type === "request_screen";
}

