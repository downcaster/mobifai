# Cursor Rules for MobiFai Project

## Git Workflow

- **NEVER automatically commit changes unless explicitly asked by the user**
- **NEVER automatically push to master unless explicitly asked by the user**
- Only stage, commit, and push when the user specifically requests it with commands like:
  - "commit this"
  - "push this"
  - "commit and push"
  - "save this to git"
- When making code changes, just make the changes and wait for the user to decide when to commit

## Project Context

- This is a React Native mobile app that connects to a Mac terminal via WebRTC P2P
- The relay server facilitates the initial connection
- Terminal rendering uses xterm.js in a WebView
- Current network: IP 192.168.178.7 (may change)

## Design System & UI

- **Framework**: React Native + NativeWind (Tailwind CSS).
- **Theme**: Material Light (Default). Use `bg-primary`, `bg-surface`, `text-black` etc.
- **Components**: ALWAYS prefer reusable components from `mobile/src/components/ui/`.
  - `AppText` for typography.
  - `AppButton` for actions.
  - `AppCard` for containers.
  - `AppView` for layout.
- **Icons**: Use standard unicode or SVGs if needed. Avoid adding heavy icon libraries unless necessary.

## TypeScript Standards (MANDATORY)

- **NO `any` types allowed**: Replace ALL `any` types with proper TypeScript types
  - Use specific interfaces, types, or `unknown` when appropriate
  - Define proper types for function parameters, return values, and variables
  - Use generic types (`<T>`) when needed for reusable code
- **Type Safety**: Enable strict TypeScript checking
  - All functions must have explicit return types
  - All parameters must have explicit types
  - No implicit `any` types
- **Environment Variables**: MUST be validated at startup
  - Use centralized config files that validate all env vars
  - Check types (especially numbers) and throw errors if invalid
  - No default values for critical environment variables
  - App must not boot if required env vars are missing or invalid

## Collaboration & Problem Solving

- **Ask for clarification**: If you're uncertain about requirements, implementation details, or user intent, ALWAYS ask additional questions before proceeding
- **Propose better alternatives**: When the user suggests a solution:
  - First consider if there's a better approach (design pattern, library, framework, standard practice)
  - If a better alternative exists, propose it with explanation before implementing
  - Examples: existing libraries vs custom code, established patterns vs ad-hoc solutions, framework features vs workarounds
  - Always explain why the alternative might be better (performance, maintainability, community support, etc.)
